= 1.10.xxxx Release
ClojureScript Team
2019-11-22
:jbake-type: post

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

## Noteworthy Changes

* Align behavior of `set/union` and `into` with Clojure.
* Align `subvec` argument checking with Clojure.
* `apply` `vector` on arrays now properly clones array.

## Google Closure Namespace Analysis

The compiler now produces analysis metadata for Google Closure namespaces.
This means that for these namespaces, you will see:

* REPL facilities like `doc`, `dir`, `apropos`, _etc._ will now work.
* Argument lists are available, thus enabling arity checking.
* Return types are available, enhancing type inference.

For example:

```
cljs.user=> (require '[goog.crypt :as crypt])
nil
cljs.user=> (dir crypt)
byteArrayToHex
byteArrayToString
hexToByteArray
...
nil
cljs.user=> (doc crypt/hexToByteArray)
-------------------------
goog.crypt/hexToByteArray
([hexString])
  /**
 * Converts a hex string into an integer array.
...
nil
cljs.user=> (crypt/hexToByteArray "abc" 123)
WARNING: Wrong number of args (2) passed to goog.crypt/hexToByteArray at line 1 <cljs repl>
...
```

## Type Inference Improvements

### Direct field access for keyword lookup on records

Example:

[source,clojure]
----
(defrecord Foo [abcd efg])
(def x (->Foo 1 2))
(:abcd x)
----

The code generated for the last expression will be `cljs.user.x.abcd`.

### `count` specializations for string and array.

If you apply `count` to a value that is statically inferred to be
either a string or an array, then the JavaScript generated will
involve a direct access to the `length` field instead of a runtime
call to `count`.

For example `(count "abc")` will cause `"abc".length` to be emitted.

### `simple-*` / `qualified-*` predicate-induced inference

If `simple-keyword?` or `qualified-keyword?` is applied to a local
then that local is inferred to be a keyword. Similarly, when
`simple-symbol?` or `qualified-symbol?` is applied to a local, then
the local is inferred to be a symbol.

This essentially broadens the existing predicate-induced inferrence
for `keyword?` and `symbol?` to these additional core predicates.

### Thread predicate-induced inference through `and`

This type inference improvement is perhaps best explained by way
of an example. For the following code

[source,clojure]
----
(and (string? x) (zero? (count x)))
----

the compiler will now know that, if the first clause in the `and` above
is satisfied, then in the second clause, `x` must be of type string.
Combined with the `count` specialization mentioned above, this causes
the JavaScript generated to be:

[source,javascript]
----
typeof x === "string" && x.length === 0
----

### Not inferring on `implements?`

This is really an internal, yet important, optimization: When the 
`implements?` predicate is satisfied on a local, the compiler generates
more efficient function dispatch code for expressions involving that local.

### Improperly widened cross-param `loop` / `recur` inference

A corner-case involving `loop` / `recur` widening inference was fixed where
incorrect inferrence can occur if a `loop`-bound local is used as a `recur`
target.

### Dynamic Vars are now properly inferred as having type `any`

An inference bug was fixed where dynamic Vars were incorrectly inferred
as having the type of their initialization value. This is incorrect
because dynamic Vars can be re-bound to have different values with types
that differ from the initialization value.

## Performance Improvements

### Optimize `assoc` on `IAssociative` values

An optimization in the core `assoc` function makes it faster when `assoc`ing
onto `IAssociative` values (the common case).

For example, `assoc`ing a key-value onto a map can be 24% faster in V8 and
11% faster in JavaScript core.

### Tag `coll` as `not-native` in `ci-reduce`

This is an important internal optimization affecting the standard library
which improves performance when reducing collections which are `IIndexed`
and `ICounted`.

### Improve perf of `cljs.source-map.base64/encode`

This improves the performance of a key function used in the generation
of source maps, improving the performance by 17% in one measurement.

## Change List

For a complete list of updates in ClojureScript 1.10.xxxx see
https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.xxxx[Changes].

## Contributors

Thanks to all of the community members who contributed to ClojureScript 1.10.xxxx:

* Dieter Komendera
* Erik Assum
* Herald
* Martin Kavalar
* Martin Kučera
* Michiel Borkent
* Roman Liutikov
* Seçkin Kükrer
* Thomas Mulvaney
